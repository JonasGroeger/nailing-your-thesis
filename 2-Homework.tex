\documentclass[a4paper,12pt,english]{scrartcl}

% Language
\usepackage{polyglossia}
\setmainlanguage[variant=american]{english}

% \today will print in format: 19th October 2014
\usepackage{isodate}
\origdate

\linespread{1.15}

% Write something in bold, sans-serif and a little larger to indicate the title
% Usage: \papertitle{DP79}{Title of the paper}
\newcommand{\papertitle}[2]{
	\noindent
	\textbf{\textsf{{\large
		[#1] #2
	}}}
	\vspace{2mm}
}

% Eigener Seitenstil (Kopf- und Fußleiste)
\usepackage{fancyhdr}
\fancyhf{} % Alles in Kopf- und Fußleisten entfernen
\fancyhead[L]{{\small \textsf{WS 14/15, NYT}}}
\fancyhead[C]{{\small \textsf{Homework 2}}}
\fancyhead[R]{{\small \textsf{19th October 2014}}}
\fancyfoot[C]{\thepage}

% Text in englischen Anführungszeichen
% Usage: \enquote{To be or not to be.}
\usepackage[autostyle=true,english=american]{csquotes}

% Ränder
\usepackage[paper=a4paper,left=20mm,right=20mm,top=30mm,bottom=30mm]{geometry}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\pagestyle{fancy} % Eigenen Seitestil aktivieren

\papertitle{DP79}{De Millo, Lipton, Perlis. 1979. Social processes and proofs of
				  theorems and programs. Commun. ACM 22, 5 (May 1979), 271-280.}

The paper is about the social processes that takes place in mathematics
regarding proofs and how this process can or cannot be applied to verification
of computer programs. At first it is argued that computer programming should
become more like mathematics. One instance how that can be done is by automatic
program verification.

Maths is a social, informal, intuitive, organic human process, a community
project. It uses proofs to verify theorems. Other than what its name suggests,
a proof is not actually what the layman thinks it is: a definitive proof that
has to be absolutely correct. In maths, a proof can only probably express the
truth. These proofs and theorems have to be believed in. This belief is created
by a social process that tries to make mathematicians feel confident about a
theorem	or a proof.

The social process starts with a proof. It is just a spoken message or at most
a sketch. If the proof generates no excitement among friends and collegues it is
most probably discarded. However, if the proof generates excitement, a
polished version will be made. After this polished version gets
published \textemdash{} it is not uncommon that papers get rejected from
journals \textemdash{} more people will read it. After a certain cooldown
period, if a larger audience likes the proof, they may belive in it. Then,
the believers will paraphrase the proof and create multiple versions of the
proof or the theorem. This will help others to understand the original authors
ideas. A believable theorem gets used as part of other proofs and in the real
world, i.e. bridges are build by inserting actual numbers in the formulas. All
these steps improve the confidence that the theorem or proof is correct. After
enough battle-testing, the theorem is not longer thought to be probably true but
absolutely true. It is included in the body of knowledge of mathematics.

This social process works very well in mathematics. There are however doubts
that program verification will work the same way or if it will work at all. It
is argued that program verification will not play the same role in Computer
Science as proofs in maths do. Verifications cannot really be read by a person.
They are too long, even for simple programs. Thus, they cannot acquire
credibility gradually (as in maths); either completely believe the result of the
verifier or don't believe in verification at all. At this point, the analogy of
program verification and mathematical proof fails as there are too many
differences.

The reason why program verification will fail is because it does not have the
same preconditions regarding programs like maths with proofs. The missing social
process is just a manifestation of that problem.

\vspace{8mm}

\papertitle{H+04}{Hevner, March, Park, Ram. 2004. Design science in information
				  systems research. MIS Q. 28, 1 (March 2004), 75-105.}

The aim of the paper is to inform the community of Information Systems
researchers about how to do research in Information Systems (IS).

In general, there are two research paradigms: behavioural science and design
science. Behavioural science has its roots in the natural sciences. It seeks to
develop and justify theories and aims at the truth. Design science has its roots
in engineering. It seeks to create innovations or artifacts and aims at utility.

The paper then introduces a framework for doing IS research using design
science. It says that regarding a top-down approach, research must address the
interaction between business strategy, Information Technology strategy,
organizational structure and IS infrastructure.

Given a business need, IS research is conducted. It uses the knowledge base
(foundations and methodologies) of IS to solve the business need. The
development is done in two complementary phases. In the first, design science
develops artifacts and theories. In the second, behavioural science assesses,
justifies and evaluates these artifacts and theories. The gained knowledge will
be used back in design science in order to refine artifacts or theories. Finally
the artifact can be used in the business environment. Knowledge gained by
building the artifact is added back to the knowledge base for future research
and application.

Lastly, the paper introduces seven guidelines for doing design science research
in IS: (1) Research must provide a viable artifact, (2) Research must solve a
business problem, (3) Quality, utility and efficacy of the artifact must be
demonstrated, (4) Research must provide contributions back to science,
(5) Rigorous methods in both development and evaluation must be used, (6) Design
using available means while including the issues of the target environment,
(7) Communicate research results in a suitable way both for management and
technology people.

\end{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Computer programming should be more like mathematics.
% 	One instance how to do that is by automatic program verification.

% Maths and proofs
% 	Maths is a social, informal, intuitive, organic human process, a community project.
% 	Maths uses proofs to verify a theorem.
% 	A proof can only probably express the truth.
% 	Those proofs and theorems have to be believed in.
% 	Belief is not generated by cold, mechanical formal logic.
% 	Belief is created by a social process that tries to make mathematicans feel condident about a theorem
% 	or a proof.

% Social processes in mathematics
% 	A proof is a spoken message or at most a sketch.
% 	If the proof generates excitement, a polished version will be made.
% 	If the polished version gets published, more people read it.
% 	After a cooldown period, if a larger audience likes the proof, they may belive in it.
% 	The believers will paraphrase the proof and create multiple versions of the theorem.
% 	A believable theorem gets used as part of other proofs and in the real world.
% 	All these steps improve the confidence that the theorem or proof is correct.
% 	After enough battle-testing, the theorem is thought to be true in the classical sense of truth.

% Proof or verification of programs
% 	Program verification will not play the same role in Computer Science as proofs in maths do.
% Class: Requirements, Specification (formal), Verification: Program -> Specification
% Class: Always full deductive formal chain, in maths there are gaps that humans can understand
% Class: Titanic effect, maybe specification is not complete. Program fails hard when boudaries are exceeded.
% 	It does not have them because the verifications cannot really be read by a person.
% 	Thus, they cannot acquire credibility gradually (as in maths); either completely believe in them or dont.
% 	The analogy of program verification and mathematical proof fails.
% 	Program verification will fail because it does not have the social processes like maths.
% Class: Reliability is a better thing to work on than verification.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Introduction
% 	Aim of the paper is to inform the community of Information Systems researchers how to do research in Information Systems.
% 	There are two research paradigms: behavioural science and design science.
% 	Behavioural science has its roots in the natural sciences. It seeks to develop and justify theories and aims at the truth.
% 	Design science has its roots in engineering. It seeks to create innovations or artifacts and aims at utility.
% A Framework for doing IS research using design science
% 	IS research must adress the interaction between business strategy, IT strategy, organizational structure and IS infrastructure
% 	The paper proposes a IS research framework.
% 	Given a business need, IS research is conducted.
% 	IS research uses the knowledge base by applying foundations and methodologies to solve the business need.
% 	The development is done in two complementary phases.
% 		Design science develops artifacts and theories.
% 		Behavioural science assesses, justifies and evaluates these artifacts and theories.
% 	The gained knowledge will be used back in design science in order to refine artifacts or theories.
% 	The artifact can now be used in the business environment.
% 	Knowledge gained through building the artifact is added to the knowledge base.

% Seven guidelines for Design Science in Information Systems Research
% 	Design as an artifact: research must produce a viable artifact.
% 	Problem relevance: Research must solve a business problem.
% 	Design Evaluation: Quality, utility and efficacy must be demonstrated.
% 	Research contributions: Research must provide contributions back to science.
% 	Research rigor: Rigorous methods in both development and evaluation must be used.
% 	Design as a Search Process: Design using available means while including the issues of the target environment.
% 	Communication of Research: both for management and technology people

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
